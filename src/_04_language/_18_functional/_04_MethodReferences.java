/*
 * Method References
 * - This section explains method references in Java, which provide a concise way to refer to existing methods without
 *   invoking them directly, improving readability and reducing boilerplate.
 *
 * Overview
 * - Method references are part of Java 8's functional programming enhancements alongside lambda expressions.
 * - They allow referring to static methods, instance methods, or constructors, and can be passed wherever a functional
 *   interface is expected.
 * - Enable direct delegation to an existing method, keeping code concise and expressive.
 * - Introduced to simplify lambda expressions that call a single method.
 *
 * Key Characteristics
 * - Provide a clean and readable way to reference existing methods.
 * - Supported for static methods, instance methods, arbitrary object methods, and constructors.
 * - Type inference ensures the method reference matches the target functional interface.
 * - Reduce boilerplate code and clarify intent when compared to equivalent lambdas.
 *
 * Types of Method References
 * - instance::instanceMethod   // Refers to an instance method of a specific object.
 * - ClassName::staticMethod    // Refers to a static method of a class.
 * - ClassName::instanceMethod  // Refers to an instance method of an arbitrary object of a particular type.
 * - ClassName::new             // Refers to a constructor.
 *
 * Type Inference & Resolution
 * - The compiler infers the target functional interface first, then resolves the method reference accordingly.
 * - Instance Method (Arbitrary Object as Receiver)
 *   - Lambda:      x -> x.instanceMethod()
 *   - Reference:   ClassName::instanceMethod
 *   - Inference:   The lambda parameter becomes the receiver of the instance method.
 * - Instance Method (Bound Receiver)
 *   - Lambda:      () -> instance.method()
 *   - Reference:   instance::instanceMethod
 *   - Inference:   The method is bound to a specific object instance.
 * - Instance Method (Receiver + Arguments)
 *   - Lambda:      (x, y) -> x.instanceMethod(y)
 *   - Reference:   ClassName::instanceMethod
 *   - Inference:   The first parameter becomes the receiver; remaining parameters are method arguments.
 * - Static Method (Direct Parameter Mapping)
 *   - Lambda:      x -> staticMethod(x)
 *   - Reference:   ClassName::staticMethod
 *   - Inference:   Lambda parameters are mapped directly to the static method parameters.
 * - Static Method (Multiple Parameters)
 *   - Lambda:      (x, y) -> staticMethod(x, y)
 *   - Reference:   ClassName::staticMethod
 *   - Inference:   All lambda parameters map directly to the static method parameters.
 * - Constructor Reference
 *   - Lambda:      x -> new ClassName(x)
 *   - Reference:   ClassName::new
 *   - Inference:   Constructor parameters are inferred from the functional interface method signature.
 *
 * Notes
 * - A method reference is not a function by itself; it is a symbolic reference that is mapped to a functional
 *   interface.
 * - At compile time, the Java compiler converts the method reference into an implementation of the target functional
 *   interface's single abstract method.
 * - The referenced method is invoked only when the functional interface method (such as apply, accept, get, or test)
 *   is explicitly called.
 * - This design exists because Java does not have native delegates or first-class function types; behavior is always
 *   represented through interfaces.
 * - As a result, method references cannot be executed directly and must always be invoked via the functional interface
 *   method.
 * - This approach preserves Java's strong typing model, backward compatibility, and object-oriented foundations.
 *
 * Usage
 * - Use method references to replace simple lambdas that call a single method.
 * - Commonly applied in streams, sorting, event handling, and functional-style processing.
 * - Example: The lambda "(s) -> s.toUpperCase()" can be replaced by "String::toUpperCase", as both perform the same
 *   operation by directly delegating to the existing method.
 */
void main() {
    //==================================================================================================================
    // Function Delegation
    //==================================================================================================================

    /*
     * Delegate Function With Method Reference
     * - Demonstrates a method reference used as a target for a functional interface.
     * - The method reference "Integer::sum" is mapped by the compiler to the single abstract method "apply" of
     *   BinaryOperator<Integer>.
     * - Java generates an implicit proxy that delegates the call to Integer.sum, applying autoboxing/unboxing as
     *   needed.
     * - Output: 5
     */
    BinaryOperator<Integer> sumFnRef = Integer::sum;
    IO.println(sumFnRef.apply(3, 2));

    /*
     * Compilation Result
     * - Shows the equivalent anonymous class generated by the compiler behind the scenes.
     * - Method references are not functions themselves; they are implemented as interface method bodies at compile
     *   time.
     * - Output: 5
     */
    BinaryOperator<Integer> compiledSumFnRef = new BinaryOperator<Integer>() {
        @Override
        public Integer apply(Integer a, Integer b) {
            return Integer.sum(a, b); // delegate to the actual method
        }
    };
    IO.println(compiledSumFnRef.apply(3, 2));

    /*
     * Delegate Function With Constructor Reference
     * - Demonstrates a constructor reference used as a target for a functional interface.
     * - The constructor reference "String::new" is mapped to the single abstract method "get" of Supplier<String>.
     * - The generated method instantiates a new object when the functional interface method is invoked.
     * - Output: ""
     */
    Supplier<String> newFnRef = String::new;
    IO.println(newFnRef.get());

    /*
     * Compilation Result
     * - Shows the equivalent anonymous class generated by the compiler for the constructor reference.
     * - Highlights that constructor references are converted into interface method implementations.
     * - Output: ""
     */
    Supplier<String> compiledNewFnRef = new Supplier<String>() {
        @Override
        public String get() {
            return new String(); // delegate to the actual constructor
        }
    };
    IO.println(compiledNewFnRef.get());

    //==================================================================================================================
    // Type Inference & Resolution
    //==================================================================================================================

    /*
     * Instance Method (Arbitrary Object as Receiver)
     * - Lambda: x -> x.instanceMethod()
     * - The lambda parameter becomes the receiver of the instance method.
     * - The first example uses a lambda expression, while the second uses a method reference.
     */
    Function<String, String> _ = x -> x.toUpperCase();
    Function<String, String> _ = String::toUpperCase;

    /*
     * Instance Method (Bound Receiver)
     * - Lambda: () -> instance.method()
     * - The method is bound to a specific object instance.
     */
    String instance = "";
    Supplier<String> _ = () -> instance.trim();
    Supplier<String> _ = instance::trim;

    /*
     * Instance Method (Receiver + Arguments)
     * - Lambda: (x, y) -> x.instanceMethod(y)
     * - The first parameter becomes the receiver; remaining parameters are method arguments.
     */
    BiPredicate<String, String> _ = (x, y) -> x.equals(y);
    BiPredicate<String, String> _ = String::equals;

    /*
     * Static Method (Direct Parameter Mapping)
     * - Lambda: x -> staticMethod(x)
     * - Lambda parameters map directly to the static method parameters.
     */
    Consumer<String> _ = x -> IO.println(x);
    Consumer<String> _ = IO::println;

    /*
     * Static Method (Multiple Parameters)
     * - Lambda: (x, y) -> staticMethod(x, y)
     * - All lambda parameters map directly to the static method parameters.
     */
    BinaryOperator<Integer> _ = (x, y) -> Integer.sum(x, y);
    BinaryOperator<Integer> _ = Integer::sum;

    /*
     * Constructor Reference
     * - Lambda: x -> new ClassName(x)
     * - Constructor parameters are inferred from the functional interface method signature.
     */
    Function<String, String> _ = x -> new String(x);
    Function<String, String> _ = String::new;
}