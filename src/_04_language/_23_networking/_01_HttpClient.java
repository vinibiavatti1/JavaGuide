/*
 * Http Client
 * - This section explains the Java HTTP Client API, which provides a modern, flexible, and asynchronous way to send
 *   HTTP requests and receive HTTP responses.
 *
 * Overview
 * - The HTTP Client API is part of the java.net.http package.
 * - It was introduced in Java 11 as a standard replacement for older HTTP handling approaches.
 * - Designed to support HTTP/1.1 and HTTP/2, with both synchronous and asynchronous communication models.
 *
 * Key Characteristics
 * - Immutable HttpClient instances created via a builder pattern.
 * - Supports synchronous (send) and asynchronous (sendAsync) requests.
 * - Provides a clean separation between HttpClient, HttpRequest, and HttpResponse.
 * - Built-in support for HTTP/2, redirects, authentication, proxies, and TLS.
 * - Integrates naturally with CompletableFuture for non-blocking and reactive-style programming.
 *
 * Usage
 * - Use HttpClient to perform HTTP calls in a modern and type-safe way.
 * - Ideal for REST APIs, web services, and client-side HTTP integrations.
 * - Prefer the asynchronous API for scalable, non-blocking applications.
 * - Suitable for replacing legacy APIs such as HttpURLConnection with clearer and more expressive code.
 */
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

void main() throws Exception {
    //==================================================================================================================
    // Declaration
    //==================================================================================================================

    /*
     * Build Client
     * - Creates a default HttpClient instance using the "HttpClient.newHttpClient" factory method.
     * - Uses the system default configuration for timeouts, proxy selection, and SSL context.
     * - The resulting HttpClient instance is immutable and thread-safe.
     * - Designed to be reused for multiple HTTP requests throughout the application lifecycle.
     * - Suitable for simple use cases where no custom configuration is required.
     */
    HttpClient client = HttpClient.newHttpClient();

    /*
     * Build Client With Basic Authenticator
     * - Creates an HttpClient configured with an Authenticator for HTTP Basic authentication.
     * - The Authenticator automatically provides credentials when the server requests authentication.
     * - Credentials are sent using the HTTP "Authorization" header with the Basic scheme.
     * - The "Authorization" header value is generated by encoding "username:password" in Base64.
     * - Authentication handling is centralized in the client, avoiding manual header management per request.
     * - Suitable for services that rely on standard HTTP authentication challenges.
     */
    client = HttpClient.newBuilder().authenticator(new Authenticator() {
        @Override
        protected PasswordAuthentication getPasswordAuthentication() {
            return new PasswordAuthentication("username", "password".toCharArray());
        }
    }).build();

    //==================================================================================================================
    // Requests
    //==================================================================================================================

    /*
     * Build Request
     * - Creates an immutable HttpRequest instance using the HttpRequest builder API.
     * - Defines the target URI explicitly via the "uri" method.
     * - Configures the HTTP method as GET using the dedicated "GET" convenience method.
     * - No request body or custom headers are specified, resulting in a simple GET request.
     * - The built request object can be safely reused and sent multiple times by an HttpClient.
     * - Output: https://httpbin.org/get GET
     */
    HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get"))
            .GET()
            .build();
    IO.println(request);

    /*
     * Build Request With Body
     * - Creates an immutable HttpRequest instance with a POST method and a request body.
     * - The target URI is defined via the "uri" method.
     * - The request body is set using "BodyPublishers.ofString", sending plain text content.
     * - Automatically sets the Content-Length header based on the body size; other headers can be added as needed.
     * - Useful for sending data to REST endpoints, APIs, or forms that accept POST requests.
     * - Output: https://httpbin.org/post POST
     */
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/post"))
            .POST(HttpRequest.BodyPublishers.ofString("Hello World"))
            .build();
    IO.println(request);

    /*
     * Build Request With Custom Method
     * - Creates an immutable HttpRequest instance using a custom HTTP method via the "method" builder.
     * - The target URI is specified with the "uri" method.
     * - The request body is explicitly set to "noBody" since OPTIONS typically does not send a payload.
     * - Allows sending HTTP methods that do not have dedicated convenience methods (e.g., OPTIONS, PATCH, TRACE).
     * - Provides flexibility for interacting with APIs that require non-standard or less common HTTP methods.
     * - Output: https://httpbin.org/options OPTIONS
     */
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/options"))
            .method("OPTIONS", HttpRequest.BodyPublishers.noBody())
            .build();
    IO.println(request);

    /*
     * Build Request With Timeout
     * - Creates an HttpRequest with a specified maximum duration for the request using the "timeout" method.
     * - If the request does not complete within the given Duration, it will be aborted and a TimeoutException is
     *   thrown.
     * - Useful for preventing long-running or hanging HTTP calls, especially in network-sensitive or real-time
     *   applications.
     * - The timeout applies to the entire request execution, including connection, request sending, and response
     *   reading.
     * - The request uses the GET method and the specified timeout.
     * - Output: https://httpbin.org/get GET
     */
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get"))
            .timeout(Duration.of(1, ChronoUnit.MINUTES))
            .GET()
            .build();
    IO.println(request);

    /*
     * Build Request With File
     * - Creates an HttpRequest that sends the contents of a file as the request body using "BodyPublishers.ofFile".
     * - The file is read from the specified Path and streamed to the server efficiently.
     * - Automatically sets the Content-Length header based on the file size; other headers can be added as needed.
     * - Useful for uploading files to APIs, web services, or endpoints that accept POST requests with binary or large
     *   data.
     * - The request uses the POST method and includes the file content as the body.
     * - Output: https://httpbin.org/get POST
     */
    Path path = Path.of("resources/request.dat");
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/post"))
            .POST(HttpRequest.BodyPublishers.ofFile(path))
            .build();
    IO.println(request);

    //==================================================================================================================
    // Headers
    //==================================================================================================================

    /*
     * Define Custom Headers
     * - Creates an HttpRequest with custom HTTP headers using the "header" method.
     * - Headers can be added for content type, accepted response types, authentication tokens, and more.
     * - Note: Some headers are restricted or managed by the HttpClient automatically (e.g., "Host", "Content-Length",
     *   "User-Agent") and cannot be overridden.
     * - The request uses the GET method with the specified headers applied.
     * - Useful for APIs that require specific headers for content negotiation or authorization.
     * - Output: https://httpbin.org/get GET
     */
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get"))
            .header("Accept", "application/json")
            .header("Content-Type", "text/plain")
            .GET()
            .build();
    IO.println(request);

    /*
     * Define Basic Authorization Header
     * - Creates an HttpRequest with a manual HTTP Basic Authorization header.
     * - The "Authorization" header uses the "Basic" scheme followed by a Base64-encoded "username:password" string.
     * - This approach bypasses the Authenticator and sends credentials directly with the request.
     * - Useful for APIs or services that require preemptive basic authentication.
     * - The request uses the GET method and includes the specified authorization header.
     * - Output: https://httpbin.org/get GET
     */
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get"))
            .header("authorization", "Basic <username:password as base64>")
            .GET()
            .build();
    IO.println(request);

    /*
     * Define Bearer Authorization Header
     * - Creates an HttpRequest with a manual HTTP Bearer Authorization header.
     * - The "Authorization" header uses the "Bearer" scheme followed by an access token.
     * - Commonly used for OAuth 2.0 or token-based authentication systems.
     * - The client sends the token directly with the request, enabling secure API access without embedding credentials.
     * - The request uses the GET method and includes the specified bearer token header.
     * - Output: https://httpbin.org/get GET
     */
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get"))
            .header("authorization", "Bearer <token>")
            .GET()
            .build();
    IO.println(request);

    //==================================================================================================================
    // Send Requests
    //==================================================================================================================

    /*
     * Send Request And Process Response
     * - Sends an HttpRequest using an HttpClient and processes the HttpResponse.
     * - The "send" method performs a synchronous request, blocking until the response is received.
     * - The response body is handled using a BodyHandler; in this case, "ofString" reads the body as a String.
     * - The HttpResponse object provides status code, headers, and body access for further processing.
     * - Useful for simple synchronous HTTP interactions, testing, or retrieving small amounts of data.
     */
    client = HttpClient.newHttpClient();
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get?page=1"))
            .GET()
            .build();
    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
    IO.println(response.statusCode()); // Output: 200
    IO.println(response.body());       // Output: { "args": { "page": "1" } }

    /*
     * Send Request And Process Response With Body
     * - Sends an HttpRequest with a POST body using an HttpClient and processes the HttpResponse.
     * - The "send" method performs a synchronous request, blocking until the response is fully received.
     * - The request body is published using "BodyPublishers.ofString", sending plain text content.
     * - The response body is handled with "BodyHandlers.ofString", providing the content as a String.
     * - The HttpResponse object gives access to status code, headers, and body for further processing.
     * - Useful for sending data to APIs, forms, or endpoints that accept POST requests.
     */
    client = HttpClient.newHttpClient();
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/post"))
            .POST(HttpRequest.BodyPublishers.ofString("Hello World"))
            .build();
    response = client.send(request, HttpResponse.BodyHandlers.ofString());
    IO.println(response.statusCode()); // Output: 200
    IO.println(response.body());       // Output: { "data": "Hello World" }

    /*
     * Send Request And Process Response With File
     * - Sends an HttpRequest and writes the response body directly to a file using "BodyHandlers.ofFile".
     * - The specified Path determines where the response bytes will be saved.
     * - The returned HttpResponse<Path> contains the same Path, confirming where the data was written.
     * - Useful for downloading binary data, files, or large responses without loading them entirely into memory.
     * - Output: File saved at: resources\response.dat
     */
    path = Path.of("resources/response.dat");
    client = HttpClient.newHttpClient();
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/bytes/10"))
            .GET()
            .build();
    HttpResponse<Path> fileResponse = client.send(request, HttpResponse.BodyHandlers.ofFile(path));
    IO.println("File saved at: " + fileResponse.body());

    //==================================================================================================================
    // Sending Async Requests
    //==================================================================================================================

    /*
     * Send And Process Request Asynchronously
     * - Sends an HttpRequest using an HttpClient in a non-blocking, asynchronous way.
     * - The "sendAsync" method returns a CompletableFuture, allowing chaining of processing steps.
     * - The response body is handled using "BodyHandlers.ofString" and extracted with "thenApply".
     * - Final processing (printing, logging, or further handling) is done with "thenAccept".
     * - Using "join" waits for the asynchronous pipeline to complete, but does not block other threads unnecessarily.
     * - Useful for scalable, non-blocking applications or parallel HTTP requests.
     * - Output: Output: { "args": { "page": "1" } }
     */
    client = HttpClient.newHttpClient();
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/get?page=1"))
            .GET()
            .build();
    client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
            .thenApply(HttpResponse::body)
            .thenAccept(IO::println)
            .join();

    /*
     * Send And Process Request With Body Asynchronously
     * - Sends an HttpRequest with a POST body using an HttpClient in a non-blocking, asynchronous way.
     * - The "sendAsync" method returns a CompletableFuture, enabling functional-style chaining of response processing.
     * - The request body is published using "BodyPublishers.ofString" to send plain text content.
     * - The response body is handled with "BodyHandlers.ofString" and extracted using "thenApply".
     * - Final processing (e.g., printing) is performed in "thenAccept"; "join" waits for completion of the asynchronous
     *   pipeline.
     * - Useful for scalable HTTP calls, concurrent requests, or integrating with reactive-style programming.
     * - Output: Output: { "data": "Hello World" }
     */
    client = HttpClient.newHttpClient();
    request = HttpRequest.newBuilder()
            .uri(URI.create("https://httpbin.org/post"))
            .POST(HttpRequest.BodyPublishers.ofString("Hello World"))
            .build();
    client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
            .thenApply(HttpResponse::body)
            .thenAccept(IO::println)
            .join();
}