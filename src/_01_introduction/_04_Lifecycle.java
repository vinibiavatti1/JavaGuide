/*
 * Lifecycle
 * - This document explains the Java application lifecycle, covering how source code is compiled into bytecode and how
 *   that bytecode is executed by the JVM, from development to runtime.
 *
 * Overview
 * - Java applications follow a two-step lifecycle: compilation and execution.
 * - Source code written in ".java" files is first compiled into platform-independent bytecode (".class" files) by the
 *   Java compiler (javac).
 * - The generated bytecode is then executed by the Java Virtual Machine (JVM) using the Java launcher (java).
 * - These commands are the foundation of all Java build tools (Maven, Gradle, IDEs), which internally delegate to javac
 *   and java.
 *
 * Lifecycle Diagram
 * - Java Source Code (.java) -> [Compilation (javac)] -> Bytecode (.class) -> [Execution on the JVM].
 *
 * Java Compiler (javac)
 * - javac is the Java source code compiler.
 * - It translates Java source files (.java) into JVM bytecode (.class), performing:
 *   - Syntax and semantic validation
 *   - Type checking and generic type erasure
 *   - Annotation processing
 *   - Generation of bytecode compatible with a target JVM version
 * - javac does not execute code; it only produces bytecode artifacts.
 *
 * Common javac Options
 * - "-d <directory>":
 *   - Specifies the output directory for compiled ".class" files.
 *   - Preserves the package directory structure inside the output directory.
 * - "-cp" or "-classpath <path>":
 *   - Defines where the compiler should look for referenced classes and libraries.
 *   - Required when compiling code that depends on external libraries or previously compiled classes.
 * - "-source <version>":
 *   - Specifies the Java language level used by the source code (syntax and language features).
 * - "-target <version>":
 *   - Specifies the JVM bytecode version to generate.
 * - "--release <version>":
 *   - Preferred modern option that sets both source and target versions consistently.
 *
 * javac Example
 * - Compiling a source file with external dependencies:
 *   - javac -cp "lib/*" -d "bin" src/com/example/MyProgram.java
 *
 * Bytecode
 * - Bytecode is the intermediate representation of Java programs produced by the Java compiler (javac).
 * - During compilation, Java source code (".java") is translated into platform-independent bytecode stored in ".class"
 *   files.
 * - Bytecode is not native machine code and cannot be executed directly by the operating system.
 * - It is designed to be executed by the Java Virtual Machine (JVM), which interprets or JIT-compiles it into native
 *   instructions at runtime.
 * - This intermediate format enables Java's portability: the same bytecode can run on any platform that provides a
 *   compatible JVM.
 * - Both javac and java operate around bytecode:
 *   - javac generates bytecode during compilation
 *   - java loads, verifies, and executes bytecode at runtime
 *
 * Java Runtime Launcher (java)
 * - java is the command-line launcher that starts a JVM instance and executes Java bytecode.
 * - It loads the specified main class or JAR, initializes the JVM, and manages the runtime environment.
 * - Responsibilities include:
 *   - Class loading and verification
 *   - Memory allocation (heap, stack, metaspace)
 *   - Just-In-Time (JIT) compilation
 *   - Thread and garbage collection management
 *
 * Common java Options
 * - "-cp" or "-classpath <path>":
 *   - Defines where the JVM should search for classes and libraries at runtime.
 * - "-jar <file.jar>":
 *   - Executes an application packaged as an executable JAR.
 *   - Ignores the classpath specified on the command line and uses the JAR manifest instead.
 * - "-Xms<size>" and "-Xmx<size>":
 *   - Configure initial and maximum heap size.
 * - "-D<key>=<value>":
 *   - Defines system properties accessible via System.getProperty().
 *
 * java Example
 * - Running a class directly from compiled bytecode:
 *   - java -cp "bin;lib/*" com.example.MyProgram
 * - Running an executable JAR:
 *   - java -jar myapp.jar
 *
 * Classpath
 * - The classpath is a configuration that tells both javac and the JVM where to locate classes and libraries.
 * - It applies at two different stages:
 *   - Compile-time: used by javac to resolve referenced types
 *   - Runtime: used by the JVM to load classes dynamically
 * - The classpath can include:
 *   - Directories containing ".class" files
 *   - JAR files
 *   - Wildcards (e.g., "lib/*")
 *
 * Key Classpath Concepts
 * - Classpath is conceptually similar to the operating system PATH variable, but applies to Java classes instead of
 *   executables.
 * - If a required class is not found on the classpath, the JVM throws:
 *   - ClassNotFoundException (runtime)
 *   - NoClassDefFoundError (class was present at compile time but missing at runtime)
 * - When running with "java -jar myapp.jar":
 *   - All classes inside the JAR are automatically available
 *   - External dependencies must be declared in the JAR manifest (Class-Path) or provided via other mechanisms
 * - For simple applications packaged as a single JAR, no explicit classpath configuration is required.
 * - Classpath becomes essential when working with:
 *   - External libraries
 *   - Modular or multi-module applications
 *   - Legacy systems without build automation
 *
 * Context in Modern Development
 * - Developers rarely invoke javac and java directly in large projects.
 * - Build tools (Maven, Gradle) and IDEs abstract these commands but ultimately rely on them.
 * - Understanding javac and java is essential for:
 *   - Debugging classpath and dependency issues
 *   - Diagnosing runtime and memory problems
 *   - Working in constrained or legacy environments
 *   - Understanding how Java applications are built and executed
 *
 * Summary
 * - javac compiles Java source code into JVM bytecode.
 * - java launches the JVM and executes compiled bytecode.
 * - Classpath controls where classes and libraries are located at compile time and runtime.
 * - These commands form the foundation of the Java build and execution model.
 */
void main() {}